use anyhow::{Context, Result, bail};
use personas_core::PersonaEntry;
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    if let Err(err) = run() {
        eprintln!("error: {err}");
        std::process::exit(1);
    }
}

fn run() -> Result<()> {
    let args = Args::parse()?;
    let repo_root = env::current_dir().context("determine repository root")?;
    let personas_dir = repo_root.join("personas");
    let docs_dir = repo_root.join("docs");
    let audit_path = docs_dir.join("PERSONA_AUDIT.md");

    if !personas_dir.is_dir() {
        bail!("personas directory missing: {}", display(&personas_dir));
    }
    if !docs_dir.is_dir() {
        bail!("docs directory missing: {}", display(&docs_dir));
    }

    let mut entries = personas_core::collect_persona_entries(&personas_dir)
        .with_context(|| format!("collect personas from {}", display(&personas_dir)))?;
    entries.sort_by(|a, b| a.meta.name.cmp(&b.meta.name));

    let markdown = render_persona_audit(&entries);

    if args.check {
        let current = fs::read_to_string(&audit_path)
            .with_context(|| format!("read {}", display(&audit_path)))?;
        if normalize_line_endings(&current) != normalize_line_endings(&markdown) {
            bail!(
                "{} is out of date. Run `cargo run -p personas-core --bin generate-persona-audit` and commit the changes.",
                display(&audit_path)
            );
        }
    } else {
        fs::write(&audit_path, markdown)
            .with_context(|| format!("write {}", display(&audit_path)))?;
        println!("wrote {}", display(&audit_path));
    }

    Ok(())
}

fn render_persona_audit(entries: &[PersonaEntry]) -> String {
    let mut output = String::new();
    output.push_str("# Persona Audit\n\n");
    output.push_str("This file is auto-generated by `cargo run -p personas-core --bin generate-persona-audit`.\n");
    output.push_str(
        "Do not edit it manually; instead, update persona metadata and rerun the generator.\n\n",
    );
    output.push_str("The table below summarizes the current Codex persona catalog.\n\n");
    output.push_str("| Persona | ID | Description | Tags | Author | Created | Version |\n");
    output.push_str("| ------ | -- | ----------- | ---- | ------ | ------- | ------- |\n");

    for entry in entries {
        let meta = &entry.meta;
        output.push_str("| ");
        output.push_str(&cell(&meta.name));
        output.push_str(" | ");
        output.push_str(&cell(&meta.id));
        output.push_str(" | ");
        output.push_str(&cell(meta.description.as_deref().unwrap_or("—")));
        output.push_str(" | ");
        output.push_str(&cell(&format_tags(meta.tags.as_ref())));
        output.push_str(" | ");
        output.push_str(&cell(meta.author.as_deref().unwrap_or("—")));
        output.push_str(" | ");
        output.push_str(&cell(meta.created_at.as_deref().unwrap_or("—")));
        output.push_str(" | ");
        output.push_str(&cell(meta.version.as_deref().unwrap_or("—")));
        output.push_str(" |\n");
    }

    output.push_str("\n## Rating Scale\n\n");
    output.push_str("- **High** — Immediately actionable with clear scope, concrete tools, and multiple example tasks.\n");
    output.push_str("- **Medium-High** — Comprehensive overall, with minor future opportunities (e.g., domain templates or advanced playbooks) but already production ready.\n");
    output.push_str("- **Medium** — Solid baseline instructions that still need richer scenarios or tool coverage before they become default-ready.\n");
    output.push_str("- **Low** — Placeholder content lacking structure or actionable guidance.\n");

    output
}

fn cell(value: &str) -> String {
    value
        .replace("\n", " ")
        .replace('|', "\\|")
        .trim()
        .to_string()
}

fn format_tags(tags: Option<&Vec<String>>) -> String {
    match tags {
        Some(list) if !list.is_empty() => list.join(", "),
        _ => "—".to_string(),
    }
}

fn normalize_line_endings(input: &str) -> String {
    input.replace("\r\n", "\n")
}

struct Args {
    check: bool,
}

impl Args {
    fn parse() -> Result<Self> {
        let mut check = false;
        for arg in env::args().skip(1) {
            match arg.as_str() {
                "--check" => check = true,
                _ => bail!("unknown argument: {arg}"),
            }
        }
        Ok(Self { check })
    }
}

fn display(path: &Path) -> String {
    path.display().to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use personas_core::PersonaMeta;

    #[test]
    fn renders_table_with_defaults() {
        let entries = vec![PersonaEntry {
            meta: PersonaMeta {
                id: "analyst".into(),
                name: "Discovery Analyst".into(),
                description: Some("Aligns goals".into()),
                tags: Some(vec!["analysis".into(), "strategy".into()]),
                author: Some("QQRM".into()),
                created_at: Some("2025-08-02".into()),
                version: Some("0.2".into()),
            },
            uri: "https://example.invalid".into(),
        }];

        let markdown = render_persona_audit(&entries);
        assert!(markdown.contains("| Discovery Analyst | analyst | Aligns goals | analysis, strategy | QQRM | 2025-08-02 | 0.2 |"));
    }
}
